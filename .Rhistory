trimmed_data$R[trimmed_data$response=="5"]<-"EE"
trimmed_data$R[trimmed_data$response=="6"]<-"FF"
trimmed_data$R = as.factor(trimmed_data$R)
dmc_data = trimmed_data %>%
filter(!is.na(R),  #remove NA values which indicate wrong key responses (27)
phase!="3") %>% #remove second phase (phase=3) - only compare pre vs delayed post
mutate(time = factor((phase=="2") +  (phase=="4")*2,levels=1:2,labels=c('pre','dpost') ),
RT=rt,
s=as.factor(as.numeric(as.character(subject)))) %>% #Forces subject numbers to be between 0 and N
select(s,S,R,time,session,RT,subject) %>%
arrange(s,session,time,S)
model <- model.dmc(p.map=list(A="1",B=c("time","session"),mean_v=c("time","session","M"),sd_v=c('time','session'),t0=c("time","session"), st0="1"),
match.map=list(M=list(aa="AA",bb="BB",cc="CC",dd="DD",ee="EE",ff="FF")),
factors=list(S=c("aa","bb","cc","dd","ee","ff"),time=c('pre','dpost'),session=c('anodal','cathodal','sham')),
constants=c(st0=0, mean_v.pre.anodal.false = 1,mean_v.dpost.anodal.false = 1,
mean_v.pre.cathodal.false = 1,mean_v.dpost.cathodal.false = 1,
mean_v.pre.sham.false = 1,mean_v.dpost.sham.false = 1),
responses=c(aa="AA",bb="BB",cc="CC",dd="DD",ee="EE",ff="FF"),
type="norm")
model <- model.dmc(p.map=list(A="1",B=c("time","session"),mean_v=c("time","session","M"),sd_v=c('time','session'),t0=c("time","session"), st0="1"),
match.map=list(M=list(aa="AA",bb="BB",cc="CC",dd="DD",ee="EE",ff="FF")),
factors=list(S=c("aa","bb","cc","dd","ee","ff"),time=c('pre','dpost'),session=c('anodal','cathodal','sham')),
constants=c(st0=0, mean_v.pre.anodal.false = 1,mean_v.dpost.anodal.false = 1,
mean_v.pre.cathodal.false = 1,mean_v.dpost.cathodal.false = 1,
mean_v.pre.sham.false = 1,mean_v.dpost.sham.false = 1),
responses=c(aa="AA",bb="BB",cc="CC",dd="DD",ee="EE",ff="FF"),
type="norm")
#Note: these priors are based off the ones used in DMC tutorial 4.6. However, in that
#tutorial, there are arbitrary differences between conditions in priors (e.g., B.r1=.6 and B.r2=0.8).
#Presumably, this is because they used the priors to simulate differences in conditions
#that could later be recovered. Here, we need the priors to be the same across conditions.
#So I've fixed all threshold, mean rate and sd rates to 1.
#subject level priors
pop.mean <- c(A=1, B.pre.anodal=1, B.dpost.anodal=1,
B.pre.cathodal=1, B.dpost.cathodal=1,
B.pre.sham=1, B.dpost.sham=1,
mean_v.pre.anodal.true=1, mean_v.dpost.anodal.true=1,
mean_v.pre.cathodal.true=1, mean_v.dpost.cathodal.true=1,
mean_v.pre.sham.true=1, mean_v.dpost.sham.true=1,
sd_v.pre.anodal=1, sd_v.dpost.anodal=1,
sd_v.pre.cathodal=1, sd_v.dpost.cathodal=1,
sd_v.pre.sham=1, sd_v.dpost.sham=1,
t0.pre.anodal=.3,t0.dpost.anodal=0.3,
t0.pre.cathodal=.3,t0.dpost.cathodal=0.3,
t0.pre.sham=.3,t0.dpost.sham=0.3)
#scales are the same as used in tutorial 4.6 (though note that they are initially specified as very small, and then multiplied by 5 on line 82)
pop.scale <- c(A=1, B.pre.anodal=1, B.dpost.anodal=1,
B.pre.cathodal=1, B.dpost.cathodal=1,
B.pre.sham=1, B.dpost.sham=1,
mean_v.pre.anodal.true=1, mean_v.dpost.anodal.true=1,
mean_v.pre.cathodal.true=1, mean_v.dpost.cathodal.true=1,
mean_v.pre.sham.true=1, mean_v.dpost.sham.true=1,
sd_v.pre.anodal=1, sd_v.dpost.anodal=1,
sd_v.pre.cathodal=1, sd_v.dpost.cathodal=1,
sd_v.pre.sham=1, sd_v.dpost.sham=1,
t0.pre.anodal=.3,t0.dpost.anodal=0.3,
t0.pre.cathodal=.3,t0.dpost.cathodal=0.3,
t0.pre.sham=.3,t0.dpost.sham=0.3)
p.prior <- prior.p.dmc(
dists = rep("tnorm",25),
p1=pop.mean,p2=pop.scale,
lower=c(0,0,0,0,0,0,0,NA,NA,NA,NA,NA,NA,0,0,0,0,0,0,.1,.1,.1,.1,.1,.1),
upper=c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,1,1,1,1,1,1)
)
#population level priors
mu.prior <- prior.p.dmc(
dists = rep("tnorm",25),
p1=pop.mean,
p2=pop.scale,
lower=c(0,0,0,0,0,0,0,NA,NA,NA,NA,NA,NA,0,0,0,0,0,0,.1,.1,.1,.1,.1,.1),
upper=c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,1,1,1,1,1,1)
)
# sigma.prior <- prior.p.dmc(
#   dists = rep("beta", length(p.prior)),
#   p1=c(A=1, B.pre.anodal=1, B.dpost.anodal=1,
#                 B.pre.cathodal=1, B.dpost.cathodal=1,
#                 B.pre.sham=1, B.dpost.sham=1,
#                 mean_v.pre.anodal.true=1, mean_v.dpost.anodal.true=1,
#                 mean_v.pre.cathodal.true=1, mean_v.dpost.cathodal.true=1,
#                 mean_v.pre.sham.true=1, mean_v.dpost.sham.true=1,
#                 mean_v.pre.anodal.false=1, mean_v.dpost.anodal.false=1,
#                 mean_v.pre.cathodal.false=1, mean_v.dpost.cathodal.false=1,
#                 mean_v.pre.sham.false=1, mean_v.dpost.sham.false=1,t0=1),
#   p2=rep(1,20) #All sd priors are uniform bounded between 0 and 1.
# )
sigma.prior <- prior.p.dmc(
dists = rep("tnorm", length(p.prior)),
p1=c(A=0, B.pre.anodal=0, B.dpost.anodal=0,
B.pre.cathodal=0, B.dpost.cathodal=0,
B.pre.sham=0, B.dpost.sham=0,
mean_v.pre.anodal.true=0, mean_v.dpost.anodal.true=0,
mean_v.pre.cathodal.true=0, mean_v.dpost.cathodal.true=0,
mean_v.pre.sham.true=0, mean_v.dpost.sham.true=0,
sd_v.pre.anodal=0, sd_v.dpost.anodal=0,
sd_v.pre.cathodal=0, sd_v.dpost.cathodal=0,
sd_v.pre.sham=0, sd_v.dpost.sham=0,
t0.pre.anodal=0,t0.dpost.anodal=0,
t0.pre.cathodal=0,t0.dpost.cathodal=0,
t0.pre.sham=0,t0.dpost.sham=0),
p2=rep(1,25), #All sd priors are unit half normals
lower=rep(0,25),
upper=rep(NA,25)
)
pp.prior <- list(mu.prior, sigma.prior)
rm(list=ls())
library(tidyverse)
source ("dmc/dmc.R")
load_model ("LBA","lba_B.R")
#load data
load(file="data/clean/trimmed_data.RData")
trimmed_data$S = NA
trimmed_data$S[trimmed_data$stimulus=="1"]<-"aa"
trimmed_data$S[trimmed_data$stimulus=="2"]<-"bb"
trimmed_data$S[trimmed_data$stimulus=="3"]<-"cc"
trimmed_data$S[trimmed_data$stimulus=="4"]<-"dd"
trimmed_data$S[trimmed_data$stimulus=="5"]<-"ee"
trimmed_data$S[trimmed_data$stimulus=="6"]<-"ff"
trimmed_data$S = as.factor(trimmed_data$S)
trimmed_data$R = NA
trimmed_data$R[trimmed_data$response=="1"]<-"AA"
trimmed_data$R[trimmed_data$response=="2"]<-"BB"
trimmed_data$R[trimmed_data$response=="3"]<-"CC"
trimmed_data$R[trimmed_data$response=="4"]<-"DD"
trimmed_data$R[trimmed_data$response=="5"]<-"EE"
trimmed_data$R[trimmed_data$response=="6"]<-"FF"
trimmed_data$R = as.factor(trimmed_data$R)
dmc_data = trimmed_data %>%
filter(!is.na(R),  #remove NA values which indicate wrong key responses (27)
phase!="3") %>% #remove second phase (phase=3) - only compare pre vs delayed post
mutate(time = factor((phase=="2") +  (phase=="4")*2,levels=1:2,labels=c('pre','dpost') ),
RT=rt,
s=as.factor(as.numeric(as.character(subject)))) %>% #Forces subject numbers to be between 0 and N
select(s,S,R,time,session,RT,subject) %>%
arrange(s,session,time,S)
#------------------
model <- model.dmc(p.map=list(A="1",B=c("time","session"),mean_v=c("time","session","M"),sd_v=c('time','session'),t0=c("time","session"), st0="1"),
match.map=list(M=list(aa="AA",bb="BB",cc="CC",dd="DD",ee="EE",ff="FF")),
factors=list(S=c("aa","bb","cc","dd","ee","ff"),time=c('pre','dpost'),session=c('anodal','cathodal','sham')),
constants=c(st0=0, mean_v.pre.anodal.false = 1,mean_v.dpost.anodal.false = 1,
mean_v.pre.cathodal.false = 1,mean_v.dpost.cathodal.false = 1,
mean_v.pre.sham.false = 1,mean_v.dpost.sham.false = 1),
responses=c(aa="AA",bb="BB",cc="CC",dd="DD",ee="EE",ff="FF"),
type="norm")
# Parameter vector names are: ( see attr(,"p.vector") )
# [1] "A"                          "B.pre.anodal"
# [3] "B.dpost.anodal"             "B.pre.cathodal"
# [5] "B.dpost.cathodal"           "B.pre.sham"
# [7] "B.dpost.sham"               "mean_v.pre.anodal.true"
# [9] "mean_v.dpost.anodal.true"   "mean_v.pre.cathodal.true"
# [11] "mean_v.dpost.cathodal.true" "mean_v.pre.sham.true"
# [13] "mean_v.dpost.sham.true"     "sd_v.pre.anodal"
# [15] "sd_v.dpost.anodal"          "sd_v.pre.cathodal"
# [17] "sd_v.dpost.cathodal"        "sd_v.pre.sham"
# [19] "sd_v.dpost.sham"            "t0.pre.anodal"
# [21] "t0.dpost.anodal"            "t0.pre.cathodal"
# [23] "t0.dpost.cathodal"          "t0.pre.sham"
# [25] "t0.dpost.sham"
#
# Constants are (see attr(,"constants") ):
#   st0     mean_v.pre.anodal.false
# 0                           1
# mean_v.dpost.anodal.false   mean_v.pre.cathodal.false
# 1                           1
# mean_v.dpost.cathodal.false       mean_v.pre.sham.false
# 1                           1
# mean_v.dpost.sham.false
# 1
#
# Model type = norm (posdrift= TRUE )
data_model <- data.model.dmc(as.data.frame(dmc_data),model)
#--------------------------------------
#Set hierarchical priors
#Note: these priors are based off the ones used in DMC tutorial 4.6. However, in that
#tutorial, there are arbitrary differences between conditions in priors (e.g., B.r1=.6 and B.r2=0.8).
#Presumably, this is because they used the priors to simulate differences in conditions
#that could later be recovered. Here, we need the priors to be the same across conditions.
#So I've fixed all threshold, mean rate and sd rates to 1.
#subject level priors
pop.mean <- c(A=1, B.pre.anodal=1, B.dpost.anodal=1,
B.pre.cathodal=1, B.dpost.cathodal=1,
B.pre.sham=1, B.dpost.sham=1,
mean_v.pre.anodal.true=1, mean_v.dpost.anodal.true=1,
mean_v.pre.cathodal.true=1, mean_v.dpost.cathodal.true=1,
mean_v.pre.sham.true=1, mean_v.dpost.sham.true=1,
sd_v.pre.anodal=1, sd_v.dpost.anodal=1,
sd_v.pre.cathodal=1, sd_v.dpost.cathodal=1,
sd_v.pre.sham=1, sd_v.dpost.sham=1,
t0.pre.anodal=.3,t0.dpost.anodal=0.3,
t0.pre.cathodal=.3,t0.dpost.cathodal=0.3,
t0.pre.sham=.3,t0.dpost.sham=0.3)
#scales are the same as used in tutorial 4.6 (though note that they are initially specified as very small, and then multiplied by 5 on line 82)
pop.scale <- c(A=1, B.pre.anodal=1, B.dpost.anodal=1,
B.pre.cathodal=1, B.dpost.cathodal=1,
B.pre.sham=1, B.dpost.sham=1,
mean_v.pre.anodal.true=1, mean_v.dpost.anodal.true=1,
mean_v.pre.cathodal.true=1, mean_v.dpost.cathodal.true=1,
mean_v.pre.sham.true=1, mean_v.dpost.sham.true=1,
sd_v.pre.anodal=1, sd_v.dpost.anodal=1,
sd_v.pre.cathodal=1, sd_v.dpost.cathodal=1,
sd_v.pre.sham=1, sd_v.dpost.sham=1,
t0.pre.anodal=.3,t0.dpost.anodal=0.3,
t0.pre.cathodal=.3,t0.dpost.cathodal=0.3,
t0.pre.sham=.3,t0.dpost.sham=0.3)
p.prior <- prior.p.dmc(
dists = rep("tnorm",25),
p1=pop.mean,p2=pop.scale,
lower=c(0,0,0,0,0,0,0,NA,NA,NA,NA,NA,NA,0,0,0,0,0,0,.1,.1,.1,.1,.1,.1),
upper=c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,1,1,1,1,1,1)
)
#population level priors
mu.prior <- prior.p.dmc(
dists = rep("tnorm",25),
p1=pop.mean,
p2=pop.scale,
lower=c(0,0,0,0,0,0,0,NA,NA,NA,NA,NA,NA,0,0,0,0,0,0,.1,.1,.1,.1,.1,.1),
upper=c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,1,1,1,1,1,1)
)
# sigma.prior <- prior.p.dmc(
#   dists = rep("beta", length(p.prior)),
#   p1=c(A=1, B.pre.anodal=1, B.dpost.anodal=1,
#                 B.pre.cathodal=1, B.dpost.cathodal=1,
#                 B.pre.sham=1, B.dpost.sham=1,
#                 mean_v.pre.anodal.true=1, mean_v.dpost.anodal.true=1,
#                 mean_v.pre.cathodal.true=1, mean_v.dpost.cathodal.true=1,
#                 mean_v.pre.sham.true=1, mean_v.dpost.sham.true=1,
#                 mean_v.pre.anodal.false=1, mean_v.dpost.anodal.false=1,
#                 mean_v.pre.cathodal.false=1, mean_v.dpost.cathodal.false=1,
#                 mean_v.pre.sham.false=1, mean_v.dpost.sham.false=1,t0=1),
#   p2=rep(1,20) #All sd priors are uniform bounded between 0 and 1.
# )
sigma.prior <- prior.p.dmc(
dists = rep("tnorm", length(p.prior)),
p1=c(A=0, B.pre.anodal=0, B.dpost.anodal=0,
B.pre.cathodal=0, B.dpost.cathodal=0,
B.pre.sham=0, B.dpost.sham=0,
mean_v.pre.anodal.true=0, mean_v.dpost.anodal.true=0,
mean_v.pre.cathodal.true=0, mean_v.dpost.cathodal.true=0,
mean_v.pre.sham.true=0, mean_v.dpost.sham.true=0,
sd_v.pre.anodal=0, sd_v.dpost.anodal=0,
sd_v.pre.cathodal=0, sd_v.dpost.cathodal=0,
sd_v.pre.sham=0, sd_v.dpost.sham=0,
t0.pre.anodal=0,t0.dpost.anodal=0,
t0.pre.cathodal=0,t0.dpost.cathodal=0,
t0.pre.sham=0,t0.dpost.sham=0),
p2=rep(1,25), #All sd priors are unit half normals
lower=rep(0,25),
upper=rep(NA,25)
)
# Make a hyper-prior list
pp.prior <- list(mu.prior, sigma.prior)
load("data/derived/dmc_final_samples_hierarchical_fixed_vf.RData")
load("data/derived/dmc_final_samples_hierarchical_fixed_vf.RData")
plot.dmc(final_samples,hyper=T)
pp=h.post.predict.dmc(samples=final_samples,save.simulation=T,cores=7)
sim = do.call(rbind, pp) %>%
mutate(prev_reps = lag(reps),
new_subject = as.numeric(reps < prev_reps))
sim$new_subject[1] = 1
sim$subject = cumsum(sim$new_subject)
sim_acc = sim %>%
#mutate(s = rownames(sim),
#        s = gsub("\\..*","",s)) %>%
mutate(correct = as.numeric(S == tolower(R))) %>%
group_by(subject,time,session,reps) %>%
mutate(accuracy = mean(correct)) %>%
group_by(time,session,reps) %>%
summarise(mean_accuracy = mean(accuracy)) %>%
group_by(time,session) %>%
summarise(prop_m = mean(mean_accuracy),
prop_l = quantile(mean_accuracy,0.025),
prop_u = quantile(mean_accuracy,0.975),
source = "Model")
data = lapply(pp, function(x) attr(x, "data"))
data = do.call(rbind, data)
data_acc = data %>%
#mutate(s = rownames(data),
#       s = gsub("\\..*","",s)) %>%
mutate(correct = as.numeric(S == tolower(R))) %>%
group_by(subject,time,session) %>%
mutate(accuracy = mean(correct)) %>%
group_by(time,session) %>%
summarise(prop_m = mean(accuracy),
prop_l = NA,#prop_m - sd(prop)/sqrt(n()),
prop_u = NA,#prop_m + sd(prop)/sqrt(n()),
source = "Data")
pp_acc =  bind_rows(data_acc,sim_acc) %>%
ungroup() %>%
mutate(Time = factor(time,levels=c('pre','dpost'),labels=c('Pre','Delayed Post')),
Session = factor(session,levels=c('anodal','cathodal','sham'),labels=c('Anodal','Cathodal','Sham'))) %>%
ggplot(aes(x=Time,y=prop_m,group=source,colour=source)) +
geom_errorbar(aes(ymax = prop_u, ymin = prop_l), width= 0.2) +
geom_point(pch=21, size=2) +
geom_line(aes(group=source)) +
ylab("Proportion Correct") + xlab('Time') +
scale_y_continuous(breaks = seq(0.5,1,0.1),limits = c(0.5,1)) +
facet_grid(.~Session)
#
pp_acc
sim_rt = sim %>%
mutate(correct = as.numeric(S == tolower(R))) %>%
group_by(subject,time,session,reps,correct) %>%
#count number of responses of each type in each condition
mutate(count = n()) %>%
#filter out responses that were made less than 5 times
filter(count >= 5) %>%
#generate quantiles
summarise(q10 = quantile(RT,.1),
q30 = quantile(RT,.3),
q50 = quantile(RT,.5),
q70 = quantile(RT,.7),
q90 = quantile(RT,.9)) %>%
gather(key=quantile,value=RT,q10:q90) %>%
#average across subjects
group_by(time,session,correct,quantile,reps) %>%
summarise(RT = mean(RT)) %>%
#get CIs
group_by(time,session,correct,quantile) %>%
summarise(RT_m = mean(RT),
RT_l = quantile(RT,0.025),
RT_u = quantile(RT,0.975),
source = "Model")
data_rt = data %>%
mutate(correct = as.numeric(S == tolower(R))) %>%
group_by(subject,time,session,correct) %>%
#count number of responses of each type in each condition
mutate(count = n()) %>%
#filter out responses that were made less than 5 times
filter(count >= 5) %>%
#generate quantiles
summarise(q10 = quantile(RT,.1),
q30 = quantile(RT,.3),
q50 = quantile(RT,.5),
q70 = quantile(RT,.7),
q90 = quantile(RT,.9)) %>%
gather(key=quantile,value=RT,q10:q90) %>%
#average across subjects
group_by(time,session,correct,quantile) %>%
summarise(RT_m = mean(RT),
RT_l = NA, #RT_m - sd(RT)/sqrt(n()),
RT_u = NA, #RT_m + sd(RT)/sqrt(n()),
source = "Data")
pp_rt =  bind_rows(data_rt,sim_rt) %>%
ungroup() %>%
mutate(Correct = factor(correct,levels=c(1,0),labels=c('Correct','Incorrect')),
Time = factor(time,levels=c('pre','dpost'),labels=c('Pre','Delayed Post')),
Session = factor(session,levels=c('anodal','cathodal','sham'),labels=c('Anodal','Cathodal','Sham'))) %>%
ggplot(aes(x=Time,y=RT_m*1000,group=quantile,colour=source)) +
geom_errorbar(aes(ymax = RT_u*1000, ymin = RT_l*1000), width= 0.2) +
geom_point(pch=21, size=2) +
geom_line(aes(group=interaction(quantile,source))) +
ylab("Response Time (ms)") + xlab('Time') +
scale_y_continuous(breaks = seq(500,2000,500),limits = c(250,2000)) +
facet_grid(Correct~Session) #+ theme_minimal()
pp_rt
rm(list=ls())
library(tidyverse)
source ("dmc/dmc.R")
load_model ("LBA","lba_B.R")
#load data
load(file="data/clean/trimmed_data.RData")
#Construct trimmed data frame which exludes missing observations
trimmed_data$S = NA
trimmed_data$S[trimmed_data$stimulus=="1"]<-"aa"
trimmed_data$S[trimmed_data$stimulus=="2"]<-"bb"
trimmed_data$S[trimmed_data$stimulus=="3"]<-"cc"
trimmed_data$S[trimmed_data$stimulus=="4"]<-"dd"
trimmed_data$S[trimmed_data$stimulus=="5"]<-"ee"
trimmed_data$S[trimmed_data$stimulus=="6"]<-"ff"
trimmed_data$S = as.factor(trimmed_data$S)
trimmed_data$R = NA
trimmed_data$R[trimmed_data$response=="1"]<-"AA"
trimmed_data$R[trimmed_data$response=="2"]<-"BB"
trimmed_data$R[trimmed_data$response=="3"]<-"CC"
trimmed_data$R[trimmed_data$response=="4"]<-"DD"
trimmed_data$R[trimmed_data$response=="5"]<-"EE"
trimmed_data$R[trimmed_data$response=="6"]<-"FF"
trimmed_data$R = as.factor(trimmed_data$R)
dmc_data = trimmed_data %>%
filter(!is.na(R),  #remove NA values which indicate wrong key responses (27)
phase!="3") %>% #remove second phase (phase=3) - only compare pre vs delayed post
mutate(time = factor((phase=="2") +  (phase=="4")*2,levels=1:2,labels=c('pre','dpost') ),
RT=rt,
s=as.factor(as.numeric(as.character(subject)))) %>% #Forces subject numbers to be between 0 and N
select(s,S,R,time,session,RT,subject) %>%
arrange(s,session,time,S)
#------------------
model <- model.dmc(p.map=list(A="1",B=c("time","session"),mean_v=c("time","session","M"),sd_v=c('time','session'),t0=c("time","session"), st0="1"),
match.map=list(M=list(aa="AA",bb="BB",cc="CC",dd="DD",ee="EE",ff="FF")),
factors=list(S=c("aa","bb","cc","dd","ee","ff"),time=c('pre','dpost'),session=c('anodal','cathodal','sham')),
constants=c(st0=0, mean_v.pre.anodal.false = 1,mean_v.dpost.anodal.false = 1,
mean_v.pre.cathodal.false = 1,mean_v.dpost.cathodal.false = 1,
mean_v.pre.sham.false = 1,mean_v.dpost.sham.false = 1),
responses=c(aa="AA",bb="BB",cc="CC",dd="DD",ee="EE",ff="FF"),
type="norm")
# Parameter vector names are: ( see attr(,"p.vector") )
# [1] "A"                          "B.pre.anodal"
# [3] "B.dpost.anodal"             "B.pre.cathodal"
# [5] "B.dpost.cathodal"           "B.pre.sham"
# [7] "B.dpost.sham"               "mean_v.pre.anodal.true"
# [9] "mean_v.dpost.anodal.true"   "mean_v.pre.cathodal.true"
# [11] "mean_v.dpost.cathodal.true" "mean_v.pre.sham.true"
# [13] "mean_v.dpost.sham.true"     "sd_v.pre.anodal"
# [15] "sd_v.dpost.anodal"          "sd_v.pre.cathodal"
# [17] "sd_v.dpost.cathodal"        "sd_v.pre.sham"
# [19] "sd_v.dpost.sham"            "t0.pre.anodal"
# [21] "t0.dpost.anodal"            "t0.pre.cathodal"
# [23] "t0.dpost.cathodal"          "t0.pre.sham"
# [25] "t0.dpost.sham"
#
# Constants are (see attr(,"constants") ):
#   st0     mean_v.pre.anodal.false
# 0                           1
# mean_v.dpost.anodal.false   mean_v.pre.cathodal.false
# 1                           1
# mean_v.dpost.cathodal.false       mean_v.pre.sham.false
# 1                           1
# mean_v.dpost.sham.false
# 1
#
# Model type = norm (posdrift= TRUE )
data_model <- data.model.dmc(as.data.frame(dmc_data),model)
#--------------------------------------
#Set hierarchical priors
#Note: these priors are based off the ones used in DMC tutorial 4.6. However, in that
#tutorial, there are arbitrary differences between conditions in priors (e.g., B.r1=.6 and B.r2=0.8).
#Presumably, this is because they used the priors to simulate differences in conditions
#that could later be recovered. Here, we need the priors to be the same across conditions.
#So I've fixed all threshold, mean rate and sd rates to 1.
#subject level priors
pop.mean <- c(A=1, B.pre.anodal=1, B.dpost.anodal=1,
B.pre.cathodal=1, B.dpost.cathodal=1,
B.pre.sham=1, B.dpost.sham=1,
mean_v.pre.anodal.true=1, mean_v.dpost.anodal.true=1,
mean_v.pre.cathodal.true=1, mean_v.dpost.cathodal.true=1,
mean_v.pre.sham.true=1, mean_v.dpost.sham.true=1,
sd_v.pre.anodal=1, sd_v.dpost.anodal=1,
sd_v.pre.cathodal=1, sd_v.dpost.cathodal=1,
sd_v.pre.sham=1, sd_v.dpost.sham=1,
t0.pre.anodal=.3,t0.dpost.anodal=0.3,
t0.pre.cathodal=.3,t0.dpost.cathodal=0.3,
t0.pre.sham=.3,t0.dpost.sham=0.3)
#scales are the same as used in tutorial 4.6 (though note that they are initially specified as very small, and then multiplied by 5 on line 82)
pop.scale <- c(A=5, B.pre.anodal=5, B.dpost.anodal=5,
B.pre.cathodal=5, B.dpost.cathodal=5,
B.pre.sham=5, B.dpost.sham=5,
mean_v.pre.anodal.true=5, mean_v.dpost.anodal.true=5,
mean_v.pre.cathodal.true=5, mean_v.dpost.cathodal.true=5,
mean_v.pre.sham.true=5, mean_v.dpost.sham.true=5,
sd_v.pre.anodal=2, sd_v.dpost.anodal=2,
sd_v.pre.cathodal=2, sd_v.dpost.cathodal=2,
sd_v.pre.sham=2, sd_v.dpost.sham=2,
t0.pre.anodal=.3,t0.dpost.anodal=0.3,
t0.pre.cathodal=.3,t0.dpost.cathodal=0.3,
t0.pre.sham=.3,t0.dpost.sham=0.3)
p.prior <- prior.p.dmc(
dists = rep("tnorm",25),
p1=pop.mean,p2=pop.scale,
lower=c(0,0,0,0,0,0,0,NA,NA,NA,NA,NA,NA,0,0,0,0,0,0,.05,.05,.05,.05,.05,.05),
upper=c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,1,1,1,1,1,1)
)
#population level priors
mu.prior <- prior.p.dmc(
dists = rep("tnorm",25),
p1=pop.mean,
p2=pop.scale,
lower=c(0,0,0,0,0,0,0,NA,NA,NA,NA,NA,NA,0,0,0,0,0,0,.05,.05,.05,.05,.05,.05),
upper=c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,1,1,1,1,1,1)
)
# sigma.prior <- prior.p.dmc(
#   dists = rep("beta", length(p.prior)),
#   p1=c(A=1, B.pre.anodal=1, B.dpost.anodal=1,
#                 B.pre.cathodal=1, B.dpost.cathodal=1,
#                 B.pre.sham=1, B.dpost.sham=1,
#                 mean_v.pre.anodal.true=1, mean_v.dpost.anodal.true=1,
#                 mean_v.pre.cathodal.true=1, mean_v.dpost.cathodal.true=1,
#                 mean_v.pre.sham.true=1, mean_v.dpost.sham.true=1,
#                 mean_v.pre.anodal.false=1, mean_v.dpost.anodal.false=1,
#                 mean_v.pre.cathodal.false=1, mean_v.dpost.cathodal.false=1,
#                 mean_v.pre.sham.false=1, mean_v.dpost.sham.false=1,t0=1),
#   p2=rep(1,20) #All sd priors are uniform bounded between 0 and 1.
# )
sigma.prior <- prior.p.dmc(
dists = rep("tnorm", length(p.prior)),
p1=c(A=0, B.pre.anodal=0, B.dpost.anodal=0,
B.pre.cathodal=0, B.dpost.cathodal=0,
B.pre.sham=0, B.dpost.sham=0,
mean_v.pre.anodal.true=0, mean_v.dpost.anodal.true=0,
mean_v.pre.cathodal.true=0, mean_v.dpost.cathodal.true=0,
mean_v.pre.sham.true=0, mean_v.dpost.sham.true=0,
sd_v.pre.anodal=0, sd_v.dpost.anodal=0,
sd_v.pre.cathodal=0, sd_v.dpost.cathodal=0,
sd_v.pre.sham=0, sd_v.dpost.sham=0,
t0.pre.anodal=0,t0.dpost.anodal=0,
t0.pre.cathodal=0,t0.dpost.cathodal=0,
t0.pre.sham=0,t0.dpost.sham=0),
p2=c(A=2, B.pre.anodal=2, B.dpost.anodal=2,
B.pre.cathodal=2, B.dpost.cathodal=2,
B.pre.sham=2, B.dpost.sham=2,
mean_v.pre.anodal.true=2, mean_v.dpost.anodal.true=2,
mean_v.pre.cathodal.true=2, mean_v.dpost.cathodal.true=2,
mean_v.pre.sham.true=2, mean_v.dpost.sham.true=2,
sd_v.pre.anodal=1, sd_v.dpost.anodal=1,
sd_v.pre.cathodal=1, sd_v.dpost.cathodal=1,
sd_v.pre.sham=1, sd_v.dpost.sham=1,
t0.pre.anodal=1,t0.dpost.anodal=1,
t0.pre.cathodal=1,t0.dpost.cathodal=1,
t0.pre.sham=1,t0.dpost.sham=1),
lower=rep(0,25),
upper=rep(NA,25)
)
# Make a hyper-prior list
pp.prior <- list(mu.prior, sigma.prior)
